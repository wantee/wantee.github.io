<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Formula Coding]]></title>
  <link href="http://wantee.github.io/atom.xml" rel="self"/>
  <link href="http://wantee.github.io/"/>
  <updated>2015-03-22T23:22:18+08:00</updated>
  <id>http://wantee.github.io/</id>
  <author>
    <name><![CDATA[Wantee Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Discriminative vs Generative]]></title>
    <link href="http://wantee.github.io/blog/2015/03/22/discriminative-vs-generative/"/>
    <updated>2015-03-22T22:44:20+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/22/discriminative-vs-generative</id>
    <content type="html"><![CDATA[<p>Models in Machine Learning can often be divided into two main categories, <em>Generative</em> and <em>Discriminative</em>.
The fundamental difference between them is:</p>

<ul>
  <li>Discriminative models learn the (hard or soft) boundary between classes</li>
  <li>Generative models model the distribution of individual classes</li>
</ul>

<p>In mathematics, discriminative models directly estimate posterior probabilities $P(y\mathop{|}x)$, while generative models model class-conditional pdfs $p(x\mathop{|}y)$ and prior probabilities $P(y)$, therefore the joint probability distributions $p(x,y)$.</p>

<p>Generative models often make some assumption on the underlying probability distributions and model it. Thus it is can be used to generate new samples from the learned distribution.</p>

<p>A simple way to distinct the two models is by considered the examples used during training. Generative model only needs examples of a particular class which it modelling. However, Discriminative model needs examples of at least two classes to find the boundary. </p>

<h2 id="examples">Examples</h2>

<p>Some models can be seen as generative-discriminative pairs, e.g.,</p>

<ul>
  <li>Classifiers: Naive Bayes and Logistic Regression</li>
  <li>Sequential Data: HMM and CRF</li>
</ul>

<p>Neutral networks are discriminative model because they compute $p(output\mathop{|}input)$.</p>

<h2 id="discriminative-and-generative-training">Discriminative and Generative Training</h2>

<p>Training approaches can also be classified as discriminative or generative. Even though with the same model, we can choose different training approaches.</p>

<p>For example, the HMM-GMM model used in speech recognition, when we do MLE training with Baum–Welch algorithm, we are using a generative training method. However when we do MPE training, we are using a discriminative training method.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: Delta]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-delta/"/>
    <updated>2015-03-14T16:57:00+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-delta</id>
    <content type="html"><![CDATA[<p>In order to use the time dynamic information of speech, One can calculate the <em>Deltas</em> and <em>Delta-Deltas</em> from the original features.</p>

<p>Also known as <em>differential</em> and <em>acceleration</em> coefficients, they are computed as,</p>

<script type="math/tex; mode=display">
d_t = \frac{\sum_{n=1}^N n(c_{t+n} - c_{t-n})}{2\sum_{n=1}^N n^2}
</script>

<p>where $d_t$ is a delta coefficient, from frame $t$  computed in terms of the static coefficients $c_{t-N}$ to $c_{t+N}$. A typical value for $N$ is 2. Delta-Delta (Acceleration) coefficients are calculated in the same way, but they are calculated from the deltas, not the static coefficients.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: Pitch]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-pitch/"/>
    <updated>2015-03-14T16:55:51+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-pitch</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: PLP]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-plp/"/>
    <updated>2015-03-14T16:55:15+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-plp</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: MFCC]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-mfcc/"/>
    <updated>2015-03-14T16:55:12+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-mfcc</id>
    <content type="html"><![CDATA[<p>Mel-frequency cepstral coefficients (MFCCs) is a popular feature used in Speech Recognition system. It is based on a concept called cepstrum.</p>

<p>The crucial observation leading to the cepstrum terminology is thatnthe log spectrum can be treated as a waveform and subjected to further Fourier analysis.
The term <em><u>ceps</u>trum</em> is coined by swapping the order of the letters in the word <em><u>spec</u>trum</em>. Likewise, the name of the independent variable of the cepstrum is known as a <em><u>quef</u>rency</em>.</p>

<p>There are a couple of slightly different <a href="http://dsp.stackexchange.com/questions/13/what-is-the-difference-between-a-fourier-transform-and-a-cosine-transform">definitions</a>. Originally cepstrum<a href="#oppenheim1968homomorphic">(Oppenheim &amp; Schafer, 1968)</a> transform was defined as </p>

<blockquote>
  <p>Fourier transform -&gt; complex logarithm -&gt; inverse Fourier transform. </p>
</blockquote>

<p>The motivation is in its ability to separate convolved signals (human speech is often modelled as the convolution of an excitation and a vocal tract).</p>

<p>MFCC has been found to perform well in speech recognition systems is to apply a non-linear filter bank in frequency domain (the mel binning). The particular algorithm<a href="#davis1980comparison">(Davis &amp; Mermelstein, 1980)</a> is defined as</p>

<blockquote>
  <p>Fourier transform -&gt; square of magnitude -&gt; mel filter bank -&gt; real logarithm -&gt; discrete cosine transform.</p>
</blockquote>

<p>Here DCT can be selected as the second transform, because for real-valued input, the real part of the DFT is a kind of DCT. The reason why DCT is preferred is that the output is approximately decorrelated. Decorrelated features can be modelled efficiently as a Gaussian distribution with a diagonal covariance matrix.</p>

<p><a href="http://dsp.stackexchange.com/questions/31/how-do-i-interpret-the-dct-step-in-the-mfcc-extraction-process">Another reason</a> is that DCT can be thought as a compression step. Typically with MFCCs, you will take the DCT and then keep only the first few coefficients. This is basically the same reason that the DCT is used in JPEG compression. DCTs are chosen because their boundary conditions work better on these types of signals.</p>

<p>Let’s contrast the DCT with the Fourier transform. The Fourier transform is made up of sinusoids that have an integer number of cycles. This means, all of the Fourier basis functions start and end at the same value – they do not do a good job of representing signals that start and end at different values. Remember that the Fourier transform assumes a periodic extension: If you imagine your signal on a sheet of paper, the Fourier transform wants to roll that sheet into a cylinder so that the left and right sides meet.</p>

<p>Think of a spectrum that is shaped roughly like a line with negative slope (which is pretty typical). The Fourier transform will have to use a lot of different coefficients to fit this shape. On the other hand, the DCT has cosines with half-integer numbers of cycles. There is, for example, a DCT basis function that looks vaguely like that line with negative slope. It does not assume a period extension (instead, an even extension), so it will do a better job of fitting that shape.</p>

<p>So, let’s put this together. Once you’ve computed the Mel-frequency spectrum, you have a representation of the spectrum that is sensitive in a way similar to how human hearing works. Some aspects of this shape are more relevant than others. Usually, the larger more overarching spectral shape is more important than the noisy fine details in the spectrum. You can imagine drawing a smooth line to follow the spectral shape, and that the smooth line you draw might tell you just about as much about the signal.</p>

<p>When you take the DCT and discard the higher coefficients, you are taking this spectral shape, and only keeping the parts that are more important for representing this smooth shape. If you used the Fourier transform, it wouldn’t do such a good job of keeping the important information in the low coefficients.</p>

<p>If we feed the MFCCs as features to a machine learning algorithm, these lower-order coefficients will make good features, since they represent some simple aspects of the spectral shape, while the higher-order coefficients that you discard are more noise-like and are not important to train on. Additionally, training on the Mel spectrum magnitudes themselves would probably not be as good because the particular amplitude at different frequencies are less important than the general shape of the spectrum.</p>

<h2 id="cepstral-analysis">Cepstral Analysis</h2>

<p>Formants of a wave carry the identity of the sound. we’d like to extract the formants and a smooth curve connecting them, i.e. the <em>spectral envelope</em>, as shown in following figure (taken from <a href="http://www.speech.cs.cmu.edu/11-492/slides/03_mfcc.pdf">this slide</a>), </p>

<p><img class="center" src="http://wantee.github.io/images/posts/spectral-envelope.png" title="Spectral Envelope" alt="fig:spectral-envelope" /></p>

<p>Cepstral analysis is a way to separate the envelope from the spectrum.
As shown in the figure , if we consider the log spectrum as waveform, the frequency(quefrency) of spectral envelope is low, while that of spectral details is high. So we can filter the low frequency region to get envelope.</p>

<p><img class="center" src="http://wantee.github.io/images/posts/cepstrum.png" title="Cepstrum" alt="fig:cepstrum" /></p>

<p>Mathematically, let $E[k]$ denotes spectral details(the periodic excitation), $H[k]$ denotes spectral envelope(vocal tract) and $X[k]$ denotes the spectrum of observed signal, then</p>

<script type="math/tex; mode=display">
X[k] = E[k]H[k] 
</script>

<script type="math/tex; mode=display">
|X[k]|=|E[k]|\,|H[k]|
</script>

<p>Taking Log on both sides</p>

<script type="math/tex; mode=display">
\log|X[k]|=\log|E[k]|+\log|H[k]|
</script>

<p>Taking inverseFFT on both sides</p>

<script type="math/tex; mode=display">
x[k]=e[k]+h[k]
</script>

<p>Now the signal are separated with a simple addition. This procedure is called de-convolution, more details can be found in <a href="http://www.speech.cs.cmu.edu/11-492/slides/03_mfcc.pdf">this slides</a>.</p>

<h2 id="mel-frequency-analysis">Mel-Frequency Analysis</h2>

<p>The Mel scale relates perceived frequency, or pitch, of a pure tone to its actual measured frequency. Humans are much better at discerning small changes in pitch at low frequencies than they are at high frequencies. Incorporating this scale makes our features match more closely what humans hear.</p>

<p>This figure  shows the Mel-scale function. we can see that Mel-scale gives more weight to low frequency regions. The values is came from human perception experiments.</p>

<p><img class="center" src="http://wantee.github.io/images/posts/mel.png" title="Mel scale" alt="fig:mel" /></p>

<h2 id="implemntation">implemntation</h2>

<p>To warp up, the complete recipe for extracting MFCC is,</p>

<ol>
  <li>Frame the signal into short frames.</li>
  <li>For each frame calculate the power spectrum.</li>
  <li>Apply the mel filterbank to the power spectra, sum the energy in each filter.</li>
  <li>Take the logarithm of all filterbank energies.</li>
  <li>Take the DCT of the log filterbank energies.</li>
  <li>Keep DCT coefficients 2-13, discard the rest.</li>
</ol>

<p><a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/">this link</a> is a nice tutorial with python code.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="oppenheim1968homomorphic">Oppenheim, A. V., &amp; Schafer, R. W. (1968). Homomorphic analysis of speech. <i>Audio and Electroacoustics, IEEE Transactions on</i>, <i>16</i>(2), 221–226.</span></li>
<li><span id="davis1980comparison">Davis, S., &amp; Mermelstein, P. (1980). <a href="http://home.iitk.ac.in/~rhegde/ee627_2015/mermelmfcc.pdf">Comparison of parametric representations for monosyllabic word recognition in continuously spoken sentences</a>. <i>Acoustics, Speech and Signal Processing, IEEE Transactions on</i>, <i>28</i>(4), 357–366.</span></li></ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: Preprocessing]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-preprocessing/"/>
    <updated>2015-03-14T16:51:02+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-preprocessing</id>
    <content type="html"><![CDATA[<p>Audio signal is constantly changing, so to simplify analysis we need first frame the signal into short frames. Then we assume the signal within the short time is statistically stationary. Typically we choose  the time of 25ms, and the frames are overlapped with shift of 10ms. If the frame is much shorter we don’t have enough samples to get a reliable spectral estimate, if it is longer the signal changes too much throughout the frame.</p>

<h2 id="dc-offset-removal">DC Offset Removal</h2>

<p>The first processing we do is to remove the <em>DC offset</em> of the signal. The DC offset is the mean value of the waveform. The term originated in electronics, where it refers to a direct current voltage. For a real sound wave propagated in the air, the mean value should equal to zero. Thus we remove the DC offset by subtracting the mean value from the original signal, i.e.,</p>

<script type="math/tex; mode=display">
x'[n] = x[n] - \frac{1}{N}\sum_ix[i]
</script>

<h2 id="pre-emphasis">Pre-emphasis</h2>

<p><a href="http://wiki.hydrogenaud.io/index.php?title=Pre-emphasis">Pre-emphasis</a> is performed for flattening the magnitude spectrum and balancing the high and low frequency components. It boosts the high frequencies component, thereby improving the signal-to-noise ratio,  before they are transmitted or recorded onto a storage medium. Upon playback, a de-emphasis filter is applied to reverse the process.</p>

<p>The reason for using pre-emphasis in speech processing, is due to the  rapid decaying spectrum of speech, when one deals with music signals , it is may not need to apply the filter. This decay in high-frequency part is seen to be suppressed during the sound production mechanism of humans. Moreover, it can also amplify the importance of high-frequency formants.</p>

<p>The formula for pre-emphasis filter is</p>

<script type="math/tex; mode=display">
x'[n] = x[n] - kx[n-1]
</script>

<p>where $k$ is the pre-emphasis coefficient which should be in the range $0 \leq k &lt; 1$, typical value is $k=0.97$.</p>

<p>Take the $z$ transform for both sides,</p>

<script type="math/tex; mode=display">
X'(z) = X(z) - kX(z)z^{-1}
</script>

<p>Therefore, $H(z) = \frac{X’(z)}{X(z)}=1-kz^{-1}$, the weight for low frequency is smaller than high frequency.</p>

<h2 id="hamming-windowing">Hamming windowing</h2>

<p><a href="http://en.wikipedia.org/wiki/Window_function#Hamming_window">Hamming windowing</a> is given by</p>

<script type="math/tex; mode=display">
x'[n] = \left\{\alpha - \beta\cos(\frac{2\pi(n-1)}{N-1})\right\}x[n]
</script>

<p>where $\alpha=0.54$ and $\beta=0.46$.</p>

<p>It is used to deal with the finite Fourier transform problem. If the start and end of the finite samples don’t match then that will look just like a discontinuity in the signal, and show up as lots of high-frequency nonsense in the Fourier transform. And if the samples happen to be a beautiful sinusoid but an integer number of periods don’t happen to fit exactly into the finite sample, your FT will show appreciable energy in all sorts of places nowhere near the real frequency. </p>

<p>Windowing the data makes sure that the ends match up while keeping everything reasonably smooth, this greatly reduces the sort of <a href="http://en.wikipedia.org/wiki/Spectral_leakage">spectral leakage</a>. Detail explanation is in <a href="https://ccrma.stanford.edu/~jos/sasp/Hamming_Window.html">this link</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Extraction for ASR: Intro]]></title>
    <link href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-intro/"/>
    <updated>2015-03-14T15:49:44+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-intro</id>
    <content type="html"><![CDATA[<p>Feature extraction is the first step for Automatic Speech Recognition(ASR), which converts the waveform speech signal to a set of feature vectors. The main goal is to make the vectors have high discrimination between phonemes.</p>

<p>Thus, the features should be</p>

<ul>
  <li>perceptually meaningful, i.e., analogous to features used by human auditory system.</li>
  <li>invariant, i.e., robust to variations in channel, speaker and
transducer.</li>
</ul>

<p>Three main steps for feature extraction are</p>

<ol>
  <li>Preprocessing</li>
  <li>Feature Analysis</li>
  <li>Parametric Transformation</li>
</ol>

<p>The <em>preprocessing</em> step converts the speech signal to a more suitable waveform for the following analysis, including <em>DC offset removal</em>, <em>pre-emphasis</em> and <em>Hamming Windowing</em>.</p>

<p><em>Feature Analysis</em> is most important step, which do most of the works. Generally, it is can be divided into two main categories, <em>Spectral Analysis</em> and <em>Temporal Analysis</em>. Spectral analysis gives MFCC and PLP features, while temporal analysis produces Energy and Pitch features. MFCC involves <em>Cepstral Analysis</em> and PLP is based on <em>Linear Predictive Coding(LPC) Analysis</em>.</p>

<p>The final step, <em>Parameter transformation</em>, converts the features obtained by above step into signal parameters through <em>differentiation</em> and <em>concatenation</em>.</p>

<p>Details are in following posts:</p>

<ol>
  <li><a href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-preprocessing/">Feature Extraction for ASR: Preprocessing</a> </li>
  <li><a href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-mfcc/">Feature Extraction for ASR: MFCC</a></li>
  <li><a href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-plp/">Feature Extraction for ASR: PLP</a></li>
  <li><a href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-pitch/">Feature Extraction for ASR: Pitch</a></li>
  <li><a href="http://wantee.github.io/blog/2015/03/14/feature-extraction-for-asr-delta/">Feature Extraction for ASR: Delta</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note on Learning Neural Network]]></title>
    <link href="http://wantee.github.io/blog/2015/03/11/note-on-learning-neural-network/"/>
    <updated>2015-03-11T16:54:37+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/11/note-on-learning-neural-network</id>
    <content type="html"><![CDATA[<p>This is a paper about back-propagation algorithm for Neural Network.</p>

<p>The table of contents is</p>

<ul>
  <li>1 Preliminary
    <ul>
      <li>1.1 Non-linear function
        <ul>
          <li>1.1.1 Sigmoid</li>
          <li>1.1.2 Hyperbolic tangent</li>
          <li>1.1.3 Softmax</li>
        </ul>
      </li>
      <li>1.2 Cross entropy</li>
      <li>1.3 Gradient descent
        <ul>
          <li>1.3.1 Batch Gradient Descent</li>
          <li>1.3.2 Stochastic Gradient Descent</li>
        </ul>
      </li>
      <li>1.4 The Multivariable Chain Rule</li>
      <li>1.5 Network architecture</li>
    </ul>
  </li>
  <li>2 Feed-forward Network
    <ul>
      <li>2.1 Forward pass</li>
      <li>2.2 Backpropagation
        <ul>
          <li>2.2.1 Weight between hidden layer and output layer</li>
          <li>2.2.2 Weight between input layer and hidden layer</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3 Recurrent Neural Network
    <ul>
      <li>3.1 Forward pass</li>
      <li>3.2 Backpropagation
        <ul>
          <li>3.2.1 Real-Time Recurrent Learning</li>
          <li>3.2.2 Backpropagation Through Time</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The pdf version is in <a href="http://wantee.github.io/assets/miscs/BP-0.3.pdf">this link</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mini-Batch Gradient Descent]]></title>
    <link href="http://wantee.github.io/blog/2015/03/10/mini-batch-gradient-descent/"/>
    <updated>2015-03-10T21:44:23+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/10/mini-batch-gradient-descent</id>
    <content type="html"><![CDATA[<p>In Mini-Batch Learning, we update the parameter $\mathbf{w}$ every $b$ examples. There are two ways to do the update.</p>

<p>First, using the summation of all examples in the mini-batch, i.e.,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:sum}
  \Delta\mathbf{w} = - \alpha_1 \sum_{i=l}^{l+b-1}{\nabla E^{(i)}}
\end{equation}</script>

<p>Second, using the average of all examples in the mini-batch, i.e.,</p>

<script type="math/tex; mode=display">\begin{equation}\label{eq:avg}
  \Delta\mathbf{w} = - \alpha_2 \frac{1}{b} \sum_{i=l}^{l+b-1}{\nabla E^{(i)}}
\end{equation}</script>

<p>From \eqref{eq:sum} and \eqref{eq:avg}, we can see that by simply scaling the learning rate, i.e. $\alpha_1 = \frac{1}{b} \alpha_2$, these two method can be equivalent. </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dropout Training]]></title>
    <link href="http://wantee.github.io/blog/2015/03/03/dropout-training/"/>
    <updated>2015-03-03T15:18:26+08:00</updated>
    <id>http://wantee.github.io/blog/2015/03/03/dropout-training</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#the-method">The Method</a></li>
  <li><a href="#implementation-in-kaldi">Implementation in Kaldi</a></li>
</ul>

<p>Dropout is a regularisation technique for reducing over-fitting in large neural nets. Hinton proposes the method in <a href="http://arxiv.org/abs/1207.0580">this paper</a>. 
Most materials are from <a href="http://www.cs.toronto.edu/~nitish/dropout/">Srivastava’s page</a>.</p>

<p>It prevents overfitting and provides a way of approximately combining exponentially many different neural network architectures efficiently. The term <em>dropout</em> refers to dropping out units (hidden and visible) in a neural network.</p>

<h2 id="the-method">The Method</h2>

<p>There are 2 key points for dropout learning: </p>

<ul>
  <li>a) Dropping units while training; </li>
  <li>b) Scaling output to be matched between training and testing. </li>
</ul>

<p>As shown in following figure , where $p$ is the dropout retention.</p>

<p><img class="center" src="http://wantee.github.io/images/posts/Dropout.png" title="Dropout" alt="fig:dropout" /></p>

<p>Units to be dropped is chosen in a random way. Note that dropping a unit out means temporarily removing it from the network, along with all its incoming and outgoing connections. Therefore we have to deal with it both during forward pass and backpropagation.</p>

<p>Applying dropout to a neural network amounts to sampling a <em>thinned</em> network from it. A neural net with $n$ units, can be seen as a collection of $2^n$ possible thinned neural networks. For each presentation of each training case, a new thinned network is sampled and trained. </p>

<p>At test time, the ideal way is to explicitly average the predictions from exponentially many thinned models, which is obviously not feasible. The intuitive way is using a single neural net without dropout at test time, however this needs some approximation. </p>

<p>The goal is that for any hidden unit the expected output (under the distribution used to drop units at training time) is the same as the actual output at test time.</p>

<p>Let $\mathbb{M}$ be the set of all thinned networks, and $\mathcal{M}$ be the network without dropout used in test time, i.e. the network containing all units. Note that, weights for all networks in $\mathbb{M}$ are shared and are equal to the ones in $\mathcal{M}$. Thus the expected output of a unit $j$ is </p>

<script type="math/tex; mode=display">
\mathbb{E}[\mathbf{y}_j] = \sum_{M \in \mathbb{M}}{Pr(M)\mathbf{y}^{M}_j}
</script>

<p>Where, $\mathbf{y}^{M}$ is the output of thinned network $M$.</p>

<p>Let $\mathbb{M}^{*}$ be the set of networks in which unit $j$ is active, then $|\mathbb{M}^{*}| = p|\mathbb{M}|$. If we assume that the probability of $M$s are equal, i.e. $Pr(M) = \frac{1}{|\mathbb{M}|}$, and assume $\mathbf{y}^{M} = \mathbf{y}^{\mathcal{M}}$, we get,</p>

<script type="math/tex; mode=display">
\mathbb{E}[\mathbf{y}_j] = p|\mathbb{M}| \frac{1}{|\mathbb{M}|} \mathbf{y}^{\mathcal{M}}_j = p\mathbf{y}^{\mathcal{M}}_j
</script>

<p>At this point, there are two method to match the training output and testing output.
First one, by scaling down the weight used at test time, i.e. $\mathbf{w}’_{ji} = p\mathbf{w}_{ji}$, we can achieve the goal. This is the way used in the above paper and shown in the figure.</p>

<p>The second way is to scale up the output at training time to the same magnitude as test time, i.e. $\mathbf{y}’_{j} = \frac{1}{p}\mathbf{y}_j$.</p>

<h2 id="implementation-in-kaldi">Implementation in Kaldi</h2>

<p>Both Karel’s and Dan’s implementation have the Dropout codes, with some differences.</p>

<p>Karel’s code(<code>src/nnet/nnet-activation.h:Dorpout</code>) uses the scale-up method to get the expected output. Dropping out is implemented during forward pass and by storing the dropped out units using a 0/1 vector, the back-propagated derivative can be set properly.</p>

<p>Dan’s code(<code>src/nnet2/net-component.cc:DropoutComponent</code>) use a clever way to avoid storing the dropping units. While backpropagation, we can get the input error $\mathbf{e_i}$ from output error $\mathbf{e_i}$ by</p>

<script type="math/tex; mode=display">
\mathbf{e_i} = \frac{\mathbf{a_o}}{\mathbf{a_i}} \mathbf{e_o}
</script>

<p>where $\mathbf{a_i}$ and $\mathbf{a_o}$ is the activation of input and output for Dropout component. Elements in $\mathbf{a_o}$ is the equal to the corresponding scaled value in $\mathbf{a_i}$, which maybe zero if it is the dropping ones.</p>

<p>Dan’s code applies a more general form of scaling. Instead of set the output of dropping unit to zero, we can just scale the output value by a factor $\alpha$. To get a proper scaled version of output, we’d like to scale all the units besides the dropping ones and make it satisfy that the expected scale factor should be 1, i.e.,</p>

<script type="math/tex; mode=display">
q \alpha + (1-q)\beta = 1
</script>

<p>where, $q=1-p$ is the dropout proportion. Therefore, we can get the factor of other units $\beta = \frac{1-q\alpha}{1-q}$. If we set $\alpha=0$, then $\beta=\frac{1}{1-q}=\frac{1}{p}$, which is equal to the scale-up factor.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RNNLIB: Connectionist Temporal Classification and Transcription Layer]]></title>
    <link href="http://wantee.github.io/blog/2015/02/08/rnnlib-connectionist-temporal-classification-and-transcription-layer/"/>
    <updated>2015-02-08T16:56:40+08:00</updated>
    <id>http://wantee.github.io/blog/2015/02/08/rnnlib-connectionist-temporal-classification-and-transcription-layer</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#the-name">The Name</a></li>
  <li><a href="#the-theory">The Theory</a>    <ul>
      <li><a href="#list-of-symbols">List of Symbols</a></li>
      <li><a href="#training-procedure">Training Procedure</a></li>
      <li><a href="#the-ctc-forward-backward-algorithm">The CTC Forward-Backward Algorithm</a></li>
    </ul>
  </li>
  <li><a href="#the-implementation">The Implementation</a></li>
  <li><a href="#decoding">Decoding</a>    <ul>
      <li><a href="#best-path-decoding">Best Path Decoding</a></li>
      <li><a href="#prefix-search-decoding">Prefix Search Decoding</a></li>
    </ul>
  </li>
</ul>

<p>CTC is the core concept make it possible to transcribe unsegmented sequence data.
RNNLIB implements it in a single layer called Transcription Layer.
We go into this particular layer in this post, the main reference is the Graves’
<a href="http://www6.in.tum.de/pub/Main/Publications/Graves2006a.pdf">original paper</a>.</p>

<p>The key point for CTC is to use a simple map transforming the RNN output to unsegmented labelling,
and construct a new objective function based on the map.
This map do not need a precise alignment, thus greatly simplify the task and reduce human expert involvement. </p>

<h2 id="the-name">The Name</h2>

<p>“Connectionist” is the adjective form of “connectionism”, 
<a href="http://en.wikipedia.org/wiki/Connectionism">Connectionism</a> is a terminology in cognitive science,
which models mental or behavioural phenomena as the emergent processes of interconnected networks of simple units.
The most common forms use neural network models. </p>

<p>In the traditional neural network recipe, we independently model the input sequence 
in each time-step or frame. This can be referred as <em>framewise classification</em>.
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.8007&amp;rep=rep1&amp;type=pdf">Kadous</a> 
extends the classification paradigm to multivariate time series, and 
names it as <em>temporal classification</em>. Mathematically, 
framewise classification models the distribution over output sequences of the <em>same</em> length as the input sequence,
nevertheless,  temporal classification models the distribution over output sequences of <em>all</em> lengths.
With this, we do not have to label every time step in training data set.</p>

<p>Combining RNN and temporal classification, Graves proposes the <em>connectionist temporal classification</em>.</p>

<p>To distinguish from classification, RNNLIB implements the CTC as <em>Transcription Layer</em>, 
indicating that with CTC we can directly transcribe input sequence(e.g. acoustic signal)
into output sequence(e.g. words).</p>

<h2 id="the-theory">The Theory</h2>

<h3 id="list-of-symbols">List of Symbols</h3>

<p>Following the notations in the paper, we first list the symbols.</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$L$</td>
      <td>(finite) alphabet of labels</td>
    </tr>
    <tr>
      <td>$L’$</td>
      <td>$L \cup {blank}$</td>
    </tr>
    <tr>
      <td>$\mathcal{X}$</td>
      <td>$(\mathbb{R}^m)^{*}$, $m$ dimensional input space</td>
    </tr>
    <tr>
      <td>$\mathcal{Z}$</td>
      <td>$L^{*}$, output space, set of all sequences over the $L$</td>
    </tr>
    <tr>
      <td>$\mathcal{D_{X \times Z}}$</td>
      <td>underlying distribution of data</td>
    </tr>
    <tr>
      <td>$S$</td>
      <td>set of training examples supposed to be drawn from $\mathcal{D_{X \times Z}}$</td>
    </tr>
    <tr>
      <td>($\mathbf{x},\mathbf{z})$</td>
      <td>example in $S$, $\mathbf{x} = (x_1, x_2, \dotsc, x_T)$, $\mathbf{z} = (z_1, z_2, \dotsc, z_U)$ and $U \leq T$</td>
    </tr>
    <tr>
      <td>$h:\mathcal{X} \mapsto \mathcal{Z}$</td>
      <td>temporal classifier to be trained</td>
    </tr>
    <tr>
      <td>$\mathcal{N}_{w}:(R^{m})^{T} \mapsto (R^n)^{T}$</td>
      <td>RNN, with $m$ inputs, $n$ outputs and weight vector $w$, as a continuous map</td>
    </tr>
    <tr>
      <td>$\mathbf{y} = \mathcal{N}_{w}$</td>
      <td>sequence of RNN output</td>
    </tr>
    <tr>
      <td>$y_{k}^{t}$</td>
      <td>the activation of output unit $k$ at time $t$</td>
    </tr>
    <tr>
      <td>$\pi$</td>
      <td><em>path</em>, element of $L’^{T}$</td>
    </tr>
    <tr>
      <td>$\mathbf{l} \in L^{\leq T}$</td>
      <td>label sequence or <em>labelling</em></td>
    </tr>
    <tr>
      <td>$\mathcal{B}:L’^{T} \mapsto L^{\leq T}$</td>
      <td>map from path to labelling</td>
    </tr>
    <tr>
      <td>$\mathbf{l}_{a\mathord{:}b}$</td>
      <td>sub-sequence of $\mathbf{l}$ from $a$th to $b$th labels</td>
    </tr>
    <tr>
      <td>$\mathbf{l}’$</td>
      <td>modified label sequence, with blanks added to the beginning and the end and inserted between every pair of labels in $\mathbf{l}$</td>
    </tr>
    <tr>
      <td>$\alpha_t(s)$</td>
      <td>forward variable, the total probability of $\mathbf{l}_{1:s}$ at time $t$</td>
    </tr>
    <tr>
      <td>$\beta_t(s)$</td>
      <td>backward variable, the total probability of $\mathbf{l}_{s:|\mathbf{l}’|}$ at time $t$</td>
    </tr>
    <tr>
      <td>$\tilde{\beta}_t(s)$</td>
      <td>backward variable, the total probability of $\mathbf{l}_{s:|\mathbf{l}’|}$ start at time $t+1$</td>
    </tr>
    <tr>
      <td>$O^{ML}(S,\mathcal{N}_{w})$</td>
      <td>maximum likelihood objective function</td>
    </tr>
    <tr>
      <td>$\delta_{kk’}$</td>
      <td><a href="http://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a></td>
    </tr>
  </tbody>
</table>

<h3 id="training-procedure">Training Procedure</h3>

<p>The goal is to use $S$ to train a temporal classifier $h$ to classify previously unseen input sequences in a way that minimises the ML objective function:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:obj_ml}
O^{ML}(S,\mathcal{N}_{w}) = - \sum_{(\mathbf{x},\mathbf{z})\in S}{\ln(p(\mathbf{z}|\mathbf{x}))}
\end{equation}</script>

<p>To train the network with gradient descent, 
we need to differentiate \eqref{eq:obj_ml} with respect to the network outputs. 
Since the training examples are independent we can consider them separately:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:obj}
\frac{\partial O^{ML}(\{(\mathbf{x},\mathbf{z}\},\mathcal{N}_{w})}{\partial y_k^t} 
    = - \frac{\partial \ln(p(\mathbf{z}|\mathbf{x}))}{\partial y_k^t}
    = - \frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{\partial p(\mathbf{z}|\mathbf{x})}{\partial y^t_k}
\end{equation}</script>

<p>Another thing we have to consider is how to map from network outputs to labellings.
Use $\mathcal{B}$ to denote such a map. Given a path, we simply removing all blanks 
and repeated labels and the remaining labels form a labelling(e.g. $\mathcal{B}(a-ab-)=\mathcal{B}(-aa–abb)=aab$). </p>

<p>Then we can define the conditional probability of a labelling,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:labelling}
p(\mathbf{l}|\mathbf{x}) = \sum_{\pi \in \mathcal{B}^{-1}(\mathbf{l})}{p(\pi|\mathbf{x})}
\end{equation}</script>

<p>where, $p(\pi|\mathbf{x})$ is the conditional probability of a path given $\mathbf{x}$, and is defined as:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:path}
p(\pi|\mathbf{x}) = \prod_{t=1}^{T}{y_{\pi_t}^{t}},\forall \pi \in L'^{T}
\end{equation}</script>

<p>To calculate \eqref{eq:obj}, we first define the forward and backward variable,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:fwd}
\alpha_t(s) = \sum_{\pi \in L^{T}:\mathcal{B}(\pi_{1\mathord{:}t})=\mathbf{l}_{1\mathord{:}s}}
   {\prod_{t'=1}^{t}{y^{t'}_{\pi_{t'}}}}
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation} \label{eq:bwd}
\beta_t(s) = \sum_{\pi \in L^{T}:\mathcal{B}(\pi_{t\mathord{:}T})=\mathbf{l}_{s\mathord{:} |\mathbf{l}'|}}
   {\prod_{t'=t}^{T}{y^{t'}_{\pi_{t'}}}}
\end{equation}</script>

<p>Note that the product of the forward and backward variables at a given $s$ and $t$ is the probability of all the paths corresponding to $\mathbf{l}$ that go through the symbol $s$ at time $t$, i.e.,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:fwd_bwd_ori}
\alpha_t(s)\beta_t(s) = \sum_{\pi \in \mathcal{B}^{-1}(\mathbf{l}):\pi_{t}=\mathbf{l}'_{s}}
   {y^{t}_{\mathbf{l}'_{s}}\prod_{t=1}^{T}{y^{t}_{\pi_{t}}}}
\end{equation}</script>

<p>Rearranging and substituting in from \eqref{eq:path} gives,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:fwd_bwd}
\frac{\alpha_t(s)\beta_t(s)}{y^{t}_{\mathbf{l}'_{s}}} = \sum_{\pi \in \mathcal{B}^{-1}(\mathbf{l}):\pi_{t}=\mathbf{l}'_{s}}
   {p(\pi|\mathbf{x})}
\end{equation}</script>

<p>For any $t$, we can therefore sum over all $s$ to get $p(\mathbf{l} | \mathbf{x})$:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:labelling_fwd_bwd}
p(\mathbf{l}|\mathbf{x}) = \sum_{s=1}^{|\mathbf{l}'|}\frac{\alpha_t(s)\beta_t(s)}{y^{t}_{\mathbf{l}'_{s}}}
\end{equation}</script>

<p>On the other hand, combining \eqref{eq:labelling} and \eqref{eq:path},</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:labelling_all}
p(\mathbf{l}|\mathbf{x}) = \sum_{\pi \in \mathcal{B}^{-1}(\mathbf{l})}{\prod_{t=1}^{T}{y_{\pi_t}^{t}}}
\end{equation}</script>

<p>Thus to differentiate this with respect to $y_k^t$ , 
we need only consider those paths going through label $k$ at time $t$
(derivatives of other paths is zero). 
Noting that the same label (or blank) may be repeated several times for a single labelling $\mathbf{l}$, 
we define the set of positions where label $k$ occurs as $lab(\mathbf{l},k) = \{s : \mathbf{l}’_s = k\}$, 
which may be empty. We then differentiate \eqref{eq:labelling_all} to get,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{equation} \label{eq:labelling_drv}
\begin{split} 
\frac{\partial p(\mathbf{l}|\mathbf{x})}{\partial y_k^t} 
  &= \sum_{s \in lab(\mathbf{l}, k)}{\frac{\partial p(\pi|\mathbf{x})}{\partial y_k^t}} \\
  &= \sum_{s \in lab(\mathbf{l}, k)}{\frac{\partial \prod_{t'=1}^{T}{y_{\pi_{t'}}^{t'}}}{\partial y_k^t}} \\
  &= \sum_{s \in lab(\mathbf{l}, k)}{\frac{\partial y_k^t\prod_{t' \neq t}{y_{\pi_{t'}}^{t'}}}{\partial y_k^t}} \\
  &= \sum_{s \in lab(\mathbf{l}, k)}{\prod_{t' \neq t}{y_{\pi_{t'}}^{t'}}} \\
  &= \frac{1}{ {y^t_k}^2 } \sum_{s \in lab(\mathbf{l}, k)}{\alpha_t(s)\beta_t(s)}
\end{split} 
\end{equation} %]]&gt;</script>

<p>At this point, we can set $\mathbf{l} = \mathbf{z}$ and substituting into \eqref{eq:obj}, then get the final gradient,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:grad}
\frac{\partial O^{ML}(\{(\mathbf{x},\mathbf{z}\},\mathcal{N}_{w})}{\partial y_k^t} 
    = - \frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{1}{ {y^t_k}^2 } \sum_{s \in lab(\mathbf{l}, k)}{\alpha_t(s)\beta_t(s)}
\end{equation}</script>

<p>where, $p(\mathbf{z}|\mathbf{x})$ can be calculated from \eqref{eq:labelling_fwd_bwd}.</p>

<p>Next, we can give the gradient for the unnormalised output $u_k^t$. Recall that derivative of softmax function is, </p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:err_softmax}
\frac{\partial y^t_{k'}}{\partial u_k^t} = y^t_{k'}\delta_{kk'} - y^t_{k'}y^t_k
\end{equation}</script>

<p>Then we get,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{equation} \label{eq:error_u}
\begin{split} 
\frac{\partial O}{\partial u_k^t} 
  &= \sum_{k'}{\frac{\partial O}{\partial y^t_{k'}}\frac{\partial y^t_{k'}}{\partial u^t_k}} \\
  &= \sum_{k'}{((y^t_{k'}\delta_{kk'} - y^t_{k'}y^t_k) (-\frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{1}{ {y^t_{k'}}^2 } 
                \sum_{s \in lab(\mathbf{l}, k')}{\alpha_t(s)\beta_t(s)}))} \\
  &= \sum_{k'}{(\frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{y^t_{k}}{ {y^t_{k'}} } 
                \sum_{s \in lab(\mathbf{l}, k')}{\alpha_t(s)\beta_t(s)})} - \frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{1}{ {y^t_k} } 
                \sum_{s \in lab(\mathbf{l}, k)}{\alpha_t(s)\beta_t(s)}\\  
  &= y^t_k - \frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{1}{ {y^t_k} } 
                \sum_{s \in lab(\mathbf{l}, k)}{\alpha_t(s)\beta_t(s)}\\                               
\end{split} 
\end{equation} %]]&gt;</script>

<p>we write the last step by noting that $\sum_{k’}\sum_{s \in lab(\mathbf{l}, k’)}{(\cdot)} \equiv \sum_{s=1}^{|\mathbf{l}’|}{(\cdot)}$,
then, using \eqref{eq:labelling_fwd_bwd}, the $p(\mathbf{z}|\mathbf{x})$ is canceled out.</p>

<h3 id="the-ctc-forward-backward-algorithm">The CTC Forward-Backward Algorithm</h3>

<p>The last thing we have to do is calculating the forward and backward variables. We now show that by define a recursive from, 
these variables can be calculated efficiently.</p>

<p>Given a labelling $\mathbf{l}$, we first extend it to $\mathbf{l}’$ with blanks added to the beginning 
and the end and inserted between every pair of labels. 
The length of $\mathbf{l}’$ is therefore $2|\mathbf{l}| + 1$. 
In calculating the probabilities of prefixes of $\mathbf{l}’$ we allow all transitions between blank and non-blank labels, 
and also those between any pair of distinct non-blank labels(because of the map $\mathcal{B}$, the repeated labels will be merged). 
We allow all prefixes to start with either a blank ($b$) or the first symbol in $\mathbf{l}$ ($\mathbf{l}_1$).</p>

<p>This gives us the following rules for initialisation</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{split} 
\alpha_1(1) &= y_b^1 \\ 
\alpha_1(2) &= y_{\mathbf{l}_1}^1 \\ 
\alpha_1(s) &= 0, \forall s > 2 \\                               
\end{split} 
 %]]&gt;</script>

<p>and recursion</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
 \begin{equation} \label{eq:alpha}
    \alpha_t(s) = \left\{\begin{array}{ll}
                                    y_{\mathbf{l}'_s}^t(\alpha_{t-1}(s) + \alpha_{t-1}(s-1)) & \mathbf{l}'_s = b\, \text{or} \, \mathbf{l}'_{s-2} = \mathbf{l}'_s\\
                                    y_{\mathbf{l}'_s}^t(\alpha_{t-1}(s) + \alpha_{t-1}(s-1) + \alpha_{t-1}(s-2)) & otherwise
                                \end{array} \right.
\end{equation} %]]&gt;</script>

<p>Note that $\alpha_t(s) = 0, \forall s &lt; |\mathbf{l}’|-2(T -t)-1$, 
because these variables correspond to states for which there are not enough time-steps left to complete the sequence.</p>

<p>Here we can get another method to calculate $p(\mathbf{l} | \mathbf{x})$, by adding up all forward variables at time $T$, i.e.,</p>

<script type="math/tex; mode=display"> \begin{equation} \label{eq:porb}
    p(\mathbf{l} | \mathbf{x}) = \alpha_T(|\mathbf{l}'|) + \alpha_T(|\mathbf{l}'| - 1)
\end{equation}</script>

<p>Similarly, the backward variables can be initalisd as,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{split} 
\beta_T(|\mathbf{l}'|) &= y_b^T \\ 
\beta_T(|\mathbf{l}'| - 1) &= y_{\mathbf{l}_{|\mathbf{l}|}}^T \\ 
\beta_T(s) &= 0, \forall s< |\mathbf{l}'| - 1\\                               
\end{split} 
 %]]&gt;</script>

<p>and recursion</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
 \begin{equation} \label{eq:beta}
    \beta_t(s) = \left\{\begin{array}{ll}
                y_{\mathbf{l}'_s}^t(\beta_{t+1}(s) + \beta_{t+1}(s+1)) & \mathbf{l}'_s = b\, \text{or} \, \mathbf{l}'_{s+2} = \mathbf{l}'_s\\
                y_{\mathbf{l}'_s}^t(\beta_{t+1}(s) + \beta_{t+1}(s+1) + \beta_{t+1}(s+2)) & otherwise
                  \end{array} \right.
\end{equation} %]]&gt;</script>

<p>Note that $\beta_t(s) = 0, \forall s &gt; 2t$.</p>

<p>Following figure  illustrate the forward backward algorithm applied to the labelling ‘CAT’(from the paper).</p>

<p><img class="center" src="http://wantee.github.io/images/posts/CTC-alpha-beta.png" title="Alpha-Beta Algorithm" alt="fig:alpha-beta" /></p>

<h2 id="the-implementation">The Implementation</h2>

<p>The <code>TranscriptionLayer</code> class inherits the <code>SoftmaxLayer</code> class(see <a href="http://wantee.github.io/blog/2015/02/05/rnnlib-softmax-layer/">this post</a>).
The <code>feed_forward()</code> and <code>feed_back()</code> methods are the general softmax function, 
so only need to implement the <code>calculate_errors()</code> method to calculate the $\frac{\partial O}{\partial y_k^t}$.
In order to use \eqref{eq:grad} to get output error, first need to calculate the $\alpha$s and $\beta$s.
Forward variables are got using \eqref{eq:alpha}. </p>

<p>But backward variables are in another form, given in Graves’ <a href="http://www6.in.tum.de/Main/Publications/Graves2008c.pdf">Dissertation</a>.
Consider backward variable started from time $t+1$,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:bwd_new}
\tilde\beta_t(s) = \sum_{\pi \in L^{T}:\mathcal{B}(\pi_{t\mathord{:}T})=\mathbf{l}_{s\mathord{:} |\mathbf{l}'|}}
   {\prod_{t'=t+1}^{T}{y^{t'}_{\pi_{t'}}}}
\end{equation}</script>

<p>Noting that, $\beta$ and $\tilde\beta$ has a simple relationship:</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:bwd_relaion}
\beta_t(s) = y_{\pi_{t}}^t\tilde\beta_t(s)
\end{equation}</script>

<p>Thus, we can get recursion formula for $\tilde\beta$ by substituting \eqref{eq:bwd_relaion} into \eqref{eq:beta},</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{split} 
\tilde\beta_T(|\mathbf{l}'|) &= 1 \\ 
\tilde\beta_T(|\mathbf{l}'| - 1) &= 1 \\ 
\tilde\beta_T(s) &= 0, \forall s< |\mathbf{l}'| - 1\\                               
\end{split} 
 %]]&gt;</script>

<script type="math/tex; mode=display">% &lt;![CDATA[
 \begin{equation} \label{eq:beta_new}
    \tilde\beta_t(s) = \left\{\begin{array}{ll}
                y_{\mathbf{l}'_s}^{t+1}\tilde\beta_{t+1}(s) + y_{\mathbf{l}'_{s+1}}^{t+1}\tilde\beta_{t+1}(s+1) & \mathbf{l}'_s = b\, \text{or} \, \mathbf{l}'_{s+2} = \mathbf{l}'_s\\
                y_{\mathbf{l}'_s}^{t+1}\tilde\beta_{t+1}(s) + y_{\mathbf{l}'_{s+1}}^{t+1}\tilde\beta_{t+1}(s+1) + y_{\mathbf{l}'_{s+2}}^{t+1}\tilde\beta_{t+1}(s+2) & otherwise
                \end{array} \right.
\end{equation} %]]&gt;</script>

<p>Noting that, if $\mathbf{l}’_s \neq blank$, then $\mathbf{l}’_{s+1}$ must be $blank$.</p>

<p>And the gradient for output \eqref{eq:grad} becomes,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:grad_new}
\frac{\partial O^{ML}(\{(\mathbf{x},\mathbf{z}\},\mathcal{N}_{w})}{\partial y_k^t} 
    = - \frac{1}{p(\mathbf{z}|\mathbf{x})} \frac{1}{ y^t_k } \sum_{s \in lab(\mathbf{l}, k)}{\alpha_t(s)\tilde\beta_t(s)}
\end{equation}</script>

<p>where,</p>

<script type="math/tex; mode=display">\begin{equation}
p(\mathbf{z}|\mathbf{x}) = \sum_{s=1}^{|\mathbf{z}'|}{\alpha_t(s)\tilde\beta_t(s)}
\end{equation}</script>

<p>Actually, the RNNLIB code computes $p(\mathbf{z}|\mathbf{x})$ using \eqref{eq:porb}.</p>

<p>To wrap up, CTC using a forward-backward algorithm to efficiently compute the RNN output errors, 
corresponding to a new ML objective function. With these errors, 
we can use any traditional gradient methods to train the network.</p>

<h2 id="decoding">Decoding</h2>

<p>Once the network is trained, we would use it to transcribe some unknown input sequence $\mathbf{x}$.
<em>Decoding</em> is referred to the task of finding the best labelling $\mathbf{l}^*$,</p>

<script type="math/tex; mode=display">\begin{equation}
\mathbf{l}^* = \mathop{\arg\!\max}\limits_{\mathbf{l}}{\,p(\mathbf{l}|\mathbf{x})}
\end{equation}</script>

<p>There are two approximate algorithms.</p>

<h3 id="best-path-decoding">Best Path Decoding</h3>

<p>This method assumes that the most probable path corresponding to the most probable labelling,</p>

<script type="math/tex; mode=display">\begin{equation}
\mathbf{l}^* \approx \mathcal{B}(\pi^*)
\end{equation}</script>

<p>where $\pi^* = \mathop{\arg\!\max}\limits_{\pi}{\,p(\pi|\mathbf{x})}$.</p>

<p>This is trivial to compute, simply by concatenating the most active outputs at every time step.
But it can lead to errors, because that the map $\mathcal{B}$ is a many-to-one map.</p>

<h3 id="prefix-search-decoding">Prefix Search Decoding</h3>

<p>By modifying the forward variables, this method can efficiently calculate the probabilities of successive extensions of labelling prefixes.</p>

<p>Prefix search decoding is a best-first search through the tree of labellings, 
where the children of a given labelling are those that share it as a prefix. 
At each step the search extends the labelling whose children have the largest cumulative probability (see below figure).</p>

<p><img class="center" src="http://wantee.github.io/images/posts/CTC-prefix-decoding.png" title="Prefix Search Decoding" alt="fig:prefix-search-decoding" /> </p>

<p>Each node either ends ($e$) or extends the prefix at its parent node. 
The number above an extending node is the total probability of all labellings beginning with that prefix. 
The number above an end node is the probability of the single labelling ending at its parent. 
At every iteration the extensions of the most probable remaining prefix are explored. 
Search ends when a single labelling (here $XY$) is more probable than any remaining prefix.</p>

<p>To extend the tree, we need to compute extended path probability, which can be computed in a recursive way.
Let $\gamma_t(\mathbf{p}_n)$ be the probability of the network outputting prefix $\mathbf{p}$
by time $t$ such that a non-blank label is output at $t$. Similarly, let $\gamma_t(\mathbf{p}_b)$ be the
probability of the network outputting prefix $\mathbf{p}$ by time $t$ such that the blank label is output at $t$. i.e.</p>

<script type="math/tex; mode=display">\begin{equation}
\gamma_t(\mathbf{p}_n) = p(\pi_{1\mathord{:}t} : \mathcal{B}(\pi_{1\mathord{:}t}) = \mathbf{p}, \pi_t = \mathbf{p}_{ | \mathbf{p} | } \mid \mathbf{x})
\end{equation}</script>

<script type="math/tex; mode=display">\begin{equation}
\gamma_t(\mathbf{p}_b) = p(\pi_{1\mathord{:}t} : \mathcal{B}(\pi_{1\mathord{:}t}) = \mathbf{p}, \pi_t = blank \mid \mathbf{x})
\end{equation}</script>

<p>Then for a length $T$ input sequence $\mathbf{x}$, $p(\mathbf{p} | \mathbf{x}) = \gamma_T(\mathbf{p}_n) + \gamma_T(\mathbf{p}_b)$.
Also let $p(\mathbf{p}\dots | \mathbf{x})$ be the cumulative probability of all labelling not equal to $\mathbf{p}$ 
of which $\mathbf{p}$ is a prefix</p>

<script type="math/tex; mode=display">\begin{equation}
p(\mathbf{p} \dotsc \mid \mathbf{x}) = \sum_{\mathbf{l} \neq \emptyset}{p(\mathbf{p} + \mathbf{l} \mid \mathbf{x})}
\end{equation}</script>

<p>where $\emptyset$ is the empty sequence. $p(\mathbf{p} \dotsc \mid \mathbf{x})$ is the value for extending node
in the prefix tree, and $p(\mathbf{p} \mid \mathbf{x})$ is the value for end node.</p>

<p>In fact, by definition, relation between $\gamma$ and $\alpha$ is,</p>

<script type="math/tex; mode=display"> \begin{equation}
    \gamma_t(\mathbf{p}_n) = \alpha_t(2 | \mathbf{p} |)
\end{equation}</script>

<script type="math/tex; mode=display"> \begin{equation}
    \gamma_t(\mathbf{p}_b) = \alpha_t(2 | \mathbf{p} | + 1)
\end{equation}</script>

<p>Using \eqref{eq:alpha}, we get the recursion for $\gamma_t(\mathbf{p}_n)$ given $\gamma_{t-1}(\mathbf{p}_n)$,
extending $\mathbf{p}^*$ to 
$\mathbf{p} = \mathbf{p}^* + k$ with label $k \in L$,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{split} 
\gamma_1(\mathbf{p}_n) &= \left\{\begin{array}{ll}
            y_k^1 & \mathbf{p}^* = \emptyset \\
            0 & \text{otherwise}
                \end{array} \right. \\ 
\gamma_1(\mathbf{p}_b) &= 0 \\                              
\end{split} 
 %]]&gt;</script>

<script type="math/tex; mode=display">% &lt;![CDATA[
 \begin{equation}
    \gamma_t(\mathbf{p}_n) = \left\{\begin{array}{ll}
                y_k^t(\gamma_{t-1}(\mathbf{p}^*_b) + \gamma_{t-1}(\mathbf{p}_n)) & \mathbf{p}^* \,\,\text{ends in} \,\, k \\
                y_k^t(\gamma_{t-1}(\mathbf{p}^*_b) + \gamma_{t-1}(\mathbf{p}^*_n) + \gamma_{t-1}(\mathbf{p}_n))  & otherwise
                \end{array} \right.
\end{equation} %]]&gt;</script>

<script type="math/tex; mode=display"> \begin{equation}
    \gamma_t(\mathbf{p}_b) = y_b^t(\gamma_{t-1}(\mathbf{p}_b) + \gamma_{t-1}(\mathbf{p}_n))
\end{equation}</script>

<p>And calculating the path probabilities,</p>

<script type="math/tex; mode=display"> \begin{equation}
    p(\mathbf{p} \mid \mathbf{x}) = \gamma_{T}(\mathbf{p}_b) + \gamma_{T}(\mathbf{p}_n)
\end{equation}</script>

<script type="math/tex; mode=display"> \begin{equation}
    p(\mathbf{p}\dotsc \mid \mathbf{x}) = \gamma_1(\mathbf{p}_n) + \sum_{t=2}^{T}{(\gamma_{t}(\mathbf{p}_n) - y^t_k \gamma_{t-1}(\mathbf{p}_n))} - p(\mathbf{p} \mid \mathbf{x})
\end{equation}</script>

<p>The extension procedure start from $\mathbf{p}^* = \emptyset$, with initialisation,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{split} 
1 \leq t \leq T & \left\{\begin{array}{ll}
            \gamma_t(\emptyset_n) &= 0 \\
            \gamma_t(\emptyset_b) &= \prod_{t'=1}^{t}y_b^{t'} \\
                \end{array} \right. \\ 
p(\emptyset \mid \mathbf{x}) &= \gamma_T(\emptyset_b) \\ 
p(\emptyset \dotsc \mid \mathbf{x}) &= 1 - p(\emptyset \mid \mathbf{x}) \\                             
\end{split} 
 %]]&gt;</script>

<p>and iterate util $\max_p p(\mathbf{p} \dotsc \mid \mathbf{x}) &lt; \max_{p’} p(\mathbf{p}’ \mid \mathbf{x})$.</p>

<p>Given enough time, prefix search decoding always finds the most probable labelling. 
However, the maximum number of prefixes it must expand grows exponentially with the input sequence length. 
We need further heuristic.</p>

<p>Observing that the outputs of a trained CTC network tend to form a series of spikes separated by strongly predicted blanks, 
we can divide the output sequence into sections that are very likely to begin and end with a blank. 
We can do this by choosing boundary points where the probability of observing a blank label is above a certain threshold, 
then apply the above algorithm to each section individually and concatenate these to get the final transcription.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RNNLIB: Softmax Layer]]></title>
    <link href="http://wantee.github.io/blog/2015/02/05/rnnlib-softmax-layer/"/>
    <updated>2015-02-05T21:08:17+08:00</updated>
    <id>http://wantee.github.io/blog/2015/02/05/rnnlib-softmax-layer</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#fundamentals">Fundamentals</a>    <ul>
      <li><a href="#list-of-symbols">List of Symbols</a></li>
      <li><a href="#formulas">Formulas</a></li>
      <li><a href="#layers-in-rnnlib">Layers in RNNLIB</a></li>
    </ul>
  </li>
  <li><a href="#forward-pass">Forward Pass</a></li>
  <li><a href="#backpropagating">Backpropagating</a></li>
</ul>

<p>I used to think that, in order to get the proper gradient, we have to take derivative of 
$\log$ of softmax with respect to weights. However,
the RNNLIB shows that we can actually factorize the network into single layers. In this post, 
we look into the Softmax Layer.</p>

<h2 id="fundamentals">Fundamentals</h2>

<h3 id="list-of-symbols">List of Symbols</h3>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$J$</td>
      <td>cost function</td>
    </tr>
    <tr>
      <td>$y_k$</td>
      <td>activation of a neon</td>
    </tr>
    <tr>
      <td>$u_k$</td>
      <td>input of a neon</td>
    </tr>
    <tr>
      <td>$S_i(\mathbf{u})$</td>
      <td>softmax function, $i$th value for a vector $\mathbf{u}$</td>
    </tr>
  </tbody>
</table>

<h3 id="formulas">Formulas</h3>

<p>Softmax of a vector $\mathbf{u}$ is defined as,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:softmax}
S_i(\mathbf{u}) = \frac{e^{u_i}}{\sum_k{e^{u_k}}} = y_i
\end{equation}</script>

<p>the derivative of softmax is,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{equation} \label{eq:softmax_dev}
    \frac{\partial S_i(\mathbf{u})}{\partial u_j} =
    \frac{\partial y_i}{\partial u_j} = 
          \left\{\begin{array}{ll}
                        y_i(1-y_i) & i = j \\
                        -y_iy_j & i \neq j 
                \end{array} \right.
\end{equation} %]]&gt;</script>

<h3 id="layers-in-rnnlib">Layers in RNNLIB</h3>

<p>Every layer in RNNLIB consists of input and output sides,
both sides contain activations and errors.
Their relations with terms in math are shown in following table,</p>

<table>
  <thead>
    <tr>
      <th>Variable</th>
      <th style="text-align: center">Term</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><em>inputActivations</em></td>
      <td style="text-align: center">$u_k$</td>
    </tr>
    <tr>
      <td><em>outputActivations</em></td>
      <td style="text-align: center">$y_k$</td>
    </tr>
    <tr>
      <td><em>inputErrors</em></td>
      <td style="text-align: center">$\frac{\partial J}{\partial u_k}$</td>
    </tr>
    <tr>
      <td><em>outputErrors</em></td>
      <td style="text-align: center">$\frac{\partial J}{\partial y_k}$</td>
    </tr>
  </tbody>
</table>

<h2 id="forward-pass">Forward Pass</h2>

<p>Forward pass computes $y_k$ from $u_k$ using equation 
\eqref{eq:softmax}. There is a trick in the code, 
we can call it the <em>safe</em> softmax.</p>

<p>To understand it, consider dividing both numerator and denominator
by $e^c$ in equation \eqref{eq:softmax}, </p>

<script type="math/tex; mode=display">\begin{equation}
S_i(\mathbf{u}) 
= \frac{\frac{e^{u_i}}{e^{c}}}{\frac{\sum_k{e^{u_k}}}{e^c}} 
= \frac{e^{u_i - c}}{\sum_k{e^{u_k - c}}} 
= S_i(\hat{\mathbf{u}})  
\end{equation}</script>

<p>thus, in order to avoid overflow when calculating exponentials<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, 
we can replace $u_k$ with $\hat{u}_k=u_k-c$. Typically, $c$ is set to $u_{max}$.</p>

<p>In RNNLIB, <script type="math/tex">c=\frac{u\_{max}+u\_{min}}{2}</script>.</p>

<h2 id="backpropagating">Backpropagating</h2>

<p>Backpropagation computes $\frac{\partial J}{\partial u_k}$ 
from $\frac{\partial J}{\partial y_k}$.</p>

<p>In RNNLIB, the result is</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:error_u_res}
\frac{\partial J}{\partial u_j} = y_j (\frac{\partial J}{\partial y_j} 
- \langle \mathbf{y}, \frac{\partial J}{\partial \mathbf{y}} \rangle)
\end{equation}</script>

<p>where, $\langle \cdot \, , \cdot \rangle$ denotes inner product.</p>

<p>To get the above equation, we first notice that variations in 
$u_j$ give rise to variations in the error function $J$ 
through variations in all $y_k$s. 
Thus, according to the <a href="https://www.math.hmc.edu/calculus/tutorials/multichainrule/">Multivariable Chain Rules</a>,
we can write,</p>

<script type="math/tex; mode=display">\begin{equation} \label{eq:error_u}
\frac{\partial J}{\partial u_j} = \sum_k{\frac{\partial J}{\partial y_k}\frac{\partial y_k}{\partial u_j}}
\end{equation}</script>

<p>Using equation \eqref{eq:softmax_dev} to replace $\frac{\partial y_k}{\partial u_j}$, we get,</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{equation} 
\begin{split}
\frac{\partial J}{\partial u_j} &= y_j(1-y_j)\frac{\partial J}{\partial y_j} +
\sum_{k: k\neq j}{-y_k y_j \frac{\partial J}{\partial y_k}} \\
&= y_j(\frac{\partial J}{\partial y_j} -y_j \frac{\partial J}{\partial y_j} 
+ \sum_{k: k\neq j}{-y_k \frac{\partial J}{\partial y_k}}) \\
&= y_j(\frac{\partial J}{\partial y_j} - \sum_{k}{y_k \frac{\partial J}{\partial y_k}}) \\
&= y_j(\frac{\partial J}{\partial y_j} - \langle \mathbf{y}, \frac{\partial J}{\partial \mathbf{y}} \rangle)
\end{split}
\end{equation} %]]&gt;</script>

<p>Finally, we reach equation \eqref{eq:error_u_res}.</p>

<p>In this way, softmax operation can be implemented to be a standalone layer.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Strictly speaking, this converts overflow into underflow. 
  Underflow is no problem, because that rounds off to zero, which is a well-behaved floating point number.
  otherwise, it will be Infinity or NaN. see <a href="http://lingpipe-blog.com/2009/03/17/softmax-without-overflow/">this article</a> for details. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RNNLIB: Introduction]]></title>
    <link href="http://wantee.github.io/blog/2015/02/05/rnnlib-introduction/"/>
    <updated>2015-02-05T16:02:28+08:00</updated>
    <id>http://wantee.github.io/blog/2015/02/05/rnnlib-introduction</id>
    <content type="html"><![CDATA[<p>RNNLIB is a recurrent neural network library for sequence learning problems,
which is written by <a href="http://www.cs.toronto.edu/~graves/">Alex Graves</a>.</p>

<p>In <a href="http://www6.in.tum.de/pub/Main/Publications/Graves2006a.pdf">this paper</a>,
Graves proposed the CTC(Connectionist Temporal Classification), 
which allows the system to transcribe unsegmented sequence data. 
The most exciting thing is that by training a deep bidirectional 
LSTM network with CTC, it is possible to 
perform automatic speech recognition in 
an <a href="http://www.jmlr.org/proceedings/papers/v32/graves14.pdf">end-to-end fashion</a>, 
i.e. without any human expertise.</p>

<p>RNNLIB covers all the theories in Graves’s paper, including:</p>

<ul>
  <li>Bidirectional Long Short-Term Memory</li>
  <li>Connectionist Temporal Classification</li>
  <li>Multidimensional Recurrent Neural Networks</li>
</ul>

<p>I will try to explain the codes in RNNLIB in following posts.</p>

<ol>
  <li><a href="http://wantee.github.io/blog/2015/02/05/rnnlib-softmax-layer/">RNNLIB: Softmax Layer</a> </li>
  <li><a href="http://wantee.github.io/blog/2015/02/08/rnnlib-connectionist-temporal-classification-and-transcription-layer/">RNNLIB: Connectionist Temporal Classification and Transcription Layer</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
