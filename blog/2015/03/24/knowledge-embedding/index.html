
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Knowledge Embedding - Formula Coding</title>
  <meta name="author" content="Wantee Wang">

  
  <meta name="description" content="Neural Networks are applied in many fields of Machine Learning. Due to their natural property, it is suitable to use them to estimate the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wantee.github.io/blog/2015/03/24/knowledge-embedding/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Formula Coding" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-58316654-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Formula Coding</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="wantee.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Knowledge Embedding</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-24T10:05:58+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:05 am</span></time>
        <span class="printable">


  


<a href="/assets/printables/2015-03-24-knowledge-embedding.pdf"> <img src="/images/printer.png" alt="printable version"> </a>

</span>

        
      </p>
    
  </header>


<div class="entry-content"><p>Neural Networks are applied in many fields of Machine Learning. Due to their natural property, it is suitable to use them to estimate the <em>distribution representations</em> from some knowledge source. This kind of representation may be referred as <em>knowledge embedding</em>.</p>

<p><a href="http://en.wikipedia.org/wiki/Embedding">Embedding</a>, mathematically, denotes one instance of some mathematical structure contained within another instance. In Machine Learning context, it often means to transfer a sparse coding of an instance to a more dense coding, e.g., a 1-of-V coding to a low dimension vector.</p>

<h2 id="word2vec">Word2Vec</h2>

<p>The first successful application of NN-based embedding is <a href="https://code.google.com/p/word2vec/">word2vec</a>, which converts a word to a continuous vector.</p>

<p>The inspiration <a href="#mikolov2013efficient">(Mikolov, Chen, Corrado, &amp; Dean, 2013)</a> of word2vec is from the observation that neutral network language model can be successfully trained in two steps: first, continuous word vectors are learned using simple model, and then the N-gram NNLM is trained on top of these distributed representations of words. Then the authors spend lots of work on learning word vectors. Thus the word-to-vector procedure can be seen as a feature extraction step for language modelling.</p>

<p>To show the innovation of word2vec, we first consider the traditional N-gram NNLM. The architecture of NNLM <a href="#bengio2003neural">(Bengio, Ducharme, Vincent, &amp; Janvin, 2003)</a> is shown in following figure </p>

<p><img class="center" src="/images/posts/nnlm.png" title="Architecture of NNLM" alt="fig:nnlm" /></p>

<p>The NNLM consists of input, projection, hidden and output layers. At the input layer, $N$ previous words are encoded using 1-of-V coding, where $V$ is size of the vocabulary. The input layer is then projected to a projection layer that has dimensionality $N \times D$. Next, projection layer is connected to the hidden layer, whose size is $H$, finally, we reach the output layer, which is of size $V$, through hidden layer.</p>

<p>Therefore, the computational complexity per each training example is</p>

<script type="math/tex; mode=display">
Q = N \times D + N \times D \times H + H \times V
</script>

<p>Where the domination term is $H \times V$. However several output layer optimisations method can avoid it, such as <em>Hierarchical Softmax</em> which reduce the output term to $H \times \log_2(V)$. Then the domination term becomes $N \times D \times H$.</p>

<p>It is can be seen from above discussion the most complexity is caused by the non-linear hidden layer in the model(if we check out the RNN LM model, same conclusion can be derived, i.e., the hidden layer occupied most computational resources).</p>

<p>However, if the goal is only to extract word embeddings, we can sacrifice some precision of NN models. This leads to the key point of speedup of word2vec, that is by <strong>removing the non-linear hidden layer</strong>, and used a log-linear model directly.</p>

<h3 id="continuous-bag-of-wordscbow-model">Continuous Bag-of-Words(CBOW) Model</h3>

<p>There are two type of log-linear models, first one is the bag-of-words model. As the name showed, it don’t consider the order of the words in history. The architecture is the same with NNLM, except that the hidden layer is removed and the projection layer is shared for all words (not just the projection matrix), as shown in the figure </p>

<p><img class="center" src="/images/posts/cbow.png" title="Architecture of CBOW" alt="fig:cbow" /></p>

<p>Another different point with traditional models is word2vec using both pre- and post-contexts of the predicting word. The training complexity is then</p>

<script type="math/tex; mode=display">
Q = N \times D + D \times \log_2(V)
</script>

<h3 id="continuous-skip-gram-model">Continuous Skip-gram Model</h3>

<p>The second model is similar to CBOW, but instead of predicting the current word based on the context, it tries to maximise classification of a word based on another word in the same sentence. More precisely, it uses each current word as an input to a log-linear classifier with continuous projection layer, and predict words within a certain range before and after the current word. The architecture is shown in the following figure </p>

<p><img class="center" src="/images/posts/skip-gram.png" title="Architecture of Skip-gram" alt="fig:skip-gram" /></p>

<p>The complexity of Skip-gram model is</p>

<script type="math/tex; mode=display">
Q = 2 \times C \times (D + D \times \log_2(V))
</script>

<p>where $C$ is the maximum distance of the words. Thus, for a particular $C$ , for each training word it will select randomly a number $R \in [1, C]$, and then use $R$ words from history and $R$ words from the future of the current word as correct labels.</p>

<p>For both CBOW and Skip-gram models, after training, the corresponding column of the projection matrix is taken out to be the vectors of one word.</p>

<p>The objective function of Skip-gram models is to maximise the average log probability </p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{O} = \frac{1}{T}\sum_{t=1}^{T} \sum_{-c \leq j \leq c, j \neq 0} \log p(w_{t+j} \mathop{|} w_t)
\end{equation}</script>

<p>where the probability $p(w_{t+j} \mathop{|} w_t)$ is defined by softmax function,</p>

<script type="math/tex; mode=display">\begin{equation}
p(w_{O} \mathop{|} w_I) = \frac{e^{\mathbf{v}^{'\top}_{w_O} \mathbf{v}_{w_I}}}{\sum_{w=1}^V e^{\mathbf{v}^{'\top}_w \mathbf{v}_{w_I}}}
\end{equation}</script>

<p>where $\mathbf{v}_w$ and $\mathbf{v}’_w$ are the “input” and “output” vector representation of $w$, which are the corresponding column of projection matrix and the weight matrix between projection and output layer.</p>

<p>After above work, <a href="#mikolov2013distributed">(Mikolov, Sutskever, Chen, Corrado, &amp; Dean, 2013)</a> proposed some method to further speedup the training, such as hierarchical softmax and negative sampling, and then extended words to phrases. We won’t go deep into these in this post.</p>

<h2 id="paragraph-to-vector">Paragraph to Vector</h2>

<p>Inspired by word2vec, <a href="#le2014distributed">(Le &amp; Mikolov, 2014)</a> extends it to transform a variable-length of text to a <em>paragraph vector</em>. The architecture is similar with CBOW, as shown in the following figure , except that the additional paragraph token in input layer, which is mapped to a vector via matrix $D$.</p>

<p><img class="center" src="/images/posts/paragraph-vec.png" title="Architecture of Paragraph Vector" alt="fig:paragraph-vec" /></p>

<p>The paragraph token can be thought of as another word. It acts as a memory that remembers what is missing from the current context – or the topic of the paragraph.</p>

<p>The contexts are fixed-length and sampled from a sliding window over the paragraph. The paragraph vector is shared across all contexts generated from the same paragraph but not across paragraphs. The word vector matrix $W$, how-ever, is shared across paragraphs.</p>

<p>At every step of stochastic gradient descent, one can sample a fixed-length context from a random paragraph, then use them to train the network.</p>

<p>At prediction time, one needs to perform an inference step to compute the paragraph vector for a new paragraph. This is also obtained by gradient descent. In this step, one can add one column in $D$ and gradient descending on $D$ while holding $W$ fixed. </p>

<p>After being trained, the paragraph vectors can also be used as features for the paragraph and be feed directly to other classifiers.</p>

<p>The most important advantages of paragraph vectors is that they are learned from unlabelled data. Besides, paragraph vectors also address some of the key weaknesses of bag-of-words models. First, they inherit an important property of the word vectors: the semantics of the words. The second advantage of the paragraph vectors is that they take into consideration the word order, at least in a small context.</p>

<h2 id="graph-to-vector">Graph to Vector</h2>

<p><a href="#tang2015line">(Tang et al., 2015)</a> further extends the embedding idea to general information networks, more specifically, it transfer the vertices in a graph to vectors.</p>

<p>The goal is to use a low-dimensional vector to represent a vertex in the graph, while preserving both local and global structure informations. To derive the model, they first formally defined the local and global similarity of vertices,</p>

<p>The local similarity is defined by <strong>First-order Proximity</strong>, which is the weight $w_{uv}$ on the edge that connected vertex $u$ and vertex $v$.</p>

<p>The <strong>Second-oder Proximity</strong> of a pair $(u, v)$ is the similarity  between their neighbourhood network structure. Mathematically, let $\mathbf{p_u} = (w_{u,1},…,w_{u,|V|})$ denotes the first-order proximity of $u$ with all the other vertices, then the second-order proximity between $u$ and $v$ is determined by the similarity between $\mathbf{p_u}$ and $\mathbf{p_v}$. The second-order proximity assumes that vertices sharing many connections to other vertices are similar to each other. </p>

<p>Thus, the graph embedding problem becomes that to convert a vertex to vector, preserving the first- and second-order proximities.</p>

<p>Their model is called <em>Large-scale Information Network Embedding(LINE)</em>. A graph is denotes by $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of edges.</p>

<h3 id="line-with-first-order-proximity">LINE with First-order Proximity</h3>

<p>To model the first-order proximity, for each undirected edge $(i, j)$, define the joint probability between vertex $v_i$ and $v_j$ as</p>

<script type="math/tex; mode=display">\begin{equation}
p_1(v_i, v_j) = \frac{1}{1 + e^{- \mathbf{u}_i^{\top} \mathbf{u}_j}}
\end{equation}</script>

<p>where $\mathbf{u}_i \in \mathbb{R}^d$ is the $d$-dimensional vector of vertex $v_i$.</p>

<p>Note that the empirical probability of $p_1(\cdot, \cdot)$ can be defined as </p>

<script type="math/tex; mode=display">\begin{equation}
\hat{p}_1(v_i, v_j) = \frac{w_{ij}}{\sum_{(i,j) \in E} w_{ij}}
\end{equation}</script>

<p>Thus the objective function of first-order proximity, is to minimise the following function</p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{O}_1 = d(\hat{p}_1(\cdot, \cdot), p_1(\cdot, \cdot))
\end{equation}</script>

<p>where $d(\cdot, \cdot)$ is the distance between two distributions. Replacing it with the KL-divergence and omitting some constants<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, </p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{O}_1 = - \sum_{(i,j) \in E} w_{ij}\log p_1(v_i, v_j)
\end{equation}</script>

<p>Note that the first-order proximity is only applicable for undirected graphs, not for directed ones.</p>

<h3 id="line-with-second-order-proximity">LINE with Second-order Proximity</h3>

<p>The second-order proximity is applicable for both directed and undirected graphs. Given a network, without loss of generality, we assume it is directed.</p>

<p>Each vertex can be treated as a specific “context” and vertices with similar distributions over the “contexts” are assumed to be similar. Therefore, each vertex plays two roles: the vertex itself and a specific “context” of other vertices. </p>

<p>Let $\mathbf{u}_i$ be the representation of $v_i$ when it is treated as a vertex, while $\mathbf{u}’_i$ is the representation of $v_i$ when it is treated as a specific “context”. For each directed edge $(i, j)$, first define the probability of “context” $v_j$ generated by vertex $v_i$ as</p>

<script type="math/tex; mode=display">\begin{equation}
p_2(v_j \mathop{|} v_i) = \frac{e^{\mathbf{u}_j^{'\top} \mathbf{u}_i}}{\sum_{k=1}^{|V|} e^{\mathbf{u}_k^{'\top} \mathbf{u}_i}}
\end{equation}</script>

<p>where $|V|$ is the number of vertices or “contexts”. </p>

<p>And the empirical probability is</p>

<script type="math/tex; mode=display">\begin{equation}
\hat{p}_2(v_j \mathop{|} v_i) = \frac{w_{ij}}{d_i}
\end{equation}</script>

<p>where $d_i$ is the out-degree of vertex $i$, i.e. $d_i = \sum_{k \in N(i)} w_{ik}$, where $N(i)$ is the set of out-neighbours of $v_i$. </p>

<p>Similarly, the objective of second-order proximity is</p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{O}_2 = \sum_{i \in V}\lambda_i d(\hat{p}_2(\cdot \mathop{|} v_i), p_2(\cdot \mathop{|} v_i))
\end{equation}</script>

<p>For simplicity, set $\lambda_i = d_i$, then replacing $d(\cdot, \cdot)$ with the KL-divergence and omitting some constants, </p>

<script type="math/tex; mode=display">\begin{equation}
\mathcal{O}_2 = - \sum_{(i,j) \in E} w_{ij}\log p_2(v_j \mathop{|} v_i)
\end{equation}</script>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="mikolov2013efficient">Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). Efficient estimation of word representations in vector space. <i>ArXiv Preprint ArXiv:1301.3781</i>.</span></li>
<li><span id="bengio2003neural">Bengio, Y., Ducharme, R., Vincent, P., &amp; Janvin, C. (2003). A neural probabilistic language model. <i>The Journal of Machine Learning Research</i>, <i>3</i>, 1137–1155.</span></li>
<li><span id="mikolov2013distributed">Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). Distributed representations of words and phrases and their compositionality. In <i>Advances in Neural Information Processing Systems</i> (pp. 3111–3119).</span></li>
<li><span id="le2014distributed">Le, Q. V., &amp; Mikolov, T. (2014). Distributed representations of sentences and documents. <i>ArXiv Preprint ArXiv:1405.4053</i>.</span></li>
<li><span id="tang2015line">Tang, J., Qu, M., Wang, M., Zhang, M., Yan, J., &amp; Mei, Q. (2015). LINE: Large-scale Information Network Embedding. <i>ArXiv Preprint ArXiv:1503.03578</i>.</span></li></ol>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>The relationship between cross entropy and KL distance is $H(\hat{p}, p) = H(\hat{p}) + D_{KL}(\hat{p}\|p)$. For the purpose of optimising the objective, $H(\hat{p})$ is constant, thus the objective is same as cross entropy. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Wantee Wang</span></span>

      




<time class='entry-date' datetime='2015-03-24T10:05:58+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:05 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/neural-network/'>neural network</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://wantee.github.io/blog/2015/03/24/knowledge-embedding/" data-via="" data-counturl="http://wantee.github.io/blog/2015/03/24/knowledge-embedding/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/03/22/discriminative-vs-generative/" title="Previous Post: Discriminative vs Generative">&laquo; Discriminative vs Generative</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/24/knowledge-embedding/">Knowledge Embedding</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/22/discriminative-vs-generative/">Discriminative vs Generative</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/14/feature-extraction-for-asr-delta/">Feature Extraction for ASR: Delta</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/14/feature-extraction-for-asr-pitch/">Feature Extraction for ASR: Pitch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/14/feature-extraction-for-asr-plp/">Feature Extraction for ASR: PLP</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/wantee">@wantee</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'wantee',
            count: 0,
            skip_forks: true,
            skip_repos: [ "wantee.github.io" ],
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Wantee Wang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'wantee';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://wantee.github.io/blog/2015/03/24/knowledge-embedding/';
        var disqus_url = 'http://wantee.github.io/blog/2015/03/24/knowledge-embedding/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>






  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

</body>
</html>
